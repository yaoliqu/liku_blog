export const articles: any = {
  list: [
    {
      classes: '杂七杂八',
      content:
        '最近在实习，写了一个小需求。本地调试没问题后，提交代码，发现一直有两个错误：\n\n```powershell\nsubject may not be empty [subject-empty]\ntype may not be empty [type-empty]\n```\n\nMentor 指出，是我提交时的 Commit Message 不规范造成的。\n\n后来自己学习了一下 Commit Message 规范，记录成此笔记，若有不妥之处，欢迎批评指出～\n\n## 1. Commit Message 组成\n\n按照业界流行的 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank">Conventional Commits</a> 的相关规定，一个 Commit Message 的格式如下：\n\n```powershell\n<type>(<scope>): <subject>\n\n[optional body]\n\n[optional footer(s)]\n```\n\n整体的格式：\n\n- 包含三个部分：Header、Body、Footer\n- 其中，Header 是必需的，而 Body 和 Footer 可选\n- 每个部分之间有一个**空行**\n- 每行内容长度不能超过 100 个字符\n\n## 2. 每部分规范说明\n\n### 1. Header（必写）\n\n```powershell\n<type>(<scope>): <subject>\n```\n\n> 注意：冒号`:`和`<subject>`之间有一个**空格**。\n\n（1）type\n\n必填项，表示本次改动的提交类型，包括的类型有：\n\n- `build`：影响内部依赖和构建的修改，例如 glup，webpack，rollup 的配置等。\n- `chore`：其他不修改`src`或`test`文件的更改。\n- `ci`：更改`CI`的配置文件。\n- `docs`：文档更新。\n- `feat`：添加新功能。\n- `fix`：修复代码库的 Bug。\n- `perf`：提升性能的更改。\n- `refactor`：代码重构，没有设计修改 Bug 和新加功能。\n- `revert`：回滚到某个 commit 的提交。\n- `style`：格式修改，不涉及程序逻辑。\n- `test`：涉及测试用例的修改。\n\n（2）scope\n\n非必填，用于描述改动的影响范围，格式为`项目名/模块名`，标识此次提交主要涉及到代码中哪个模块。\n\n（3）subject\n\n必填项，此次提交的**描述内容**，语语句尽量简短。\n\n- 以动词原型开头，比如`change`，而不是`changes`\n- 第一个字母小写\n- 结尾不加句号`.`\n\n### 2. Body（可选）\n\nBody 部分是针对本次 commit 的**详细描述**，内容较长时，要进行合理的换行，要表达清楚变动的动机以及与之前行为的对比。好的提交信息要回答下面的内容：\n\n- 为什么要提交这次修改？\n- 怎么解决的问题？\n- 可能影响哪些内容？\n\n如果在 Body 上需要附上相关链接，则`ref: url`。\n\n### 3. Footer（可选）\n\nFooter 部分只用于两种情况：\n\n- BREAKING CHANGE（不兼容变动）\n- 关闭 Issue\n\n## 3. 一些 Commit 举例\n\n都省略了 Body 和 Footer。\n\n```powershell\nchore: run tests on travis ci\n```\n\n```powershell\nfix(server): send cors headers\n```\n\n```powershell\nfeat(blog): add comment section\n```\n\n## 4. 使用 commitlint 进行规范检查\n\ncommitlint 可以检查 Commit Message 是否符合 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank">Conventional Commits</a> 的格式。\n\n详情配置见 <a href="https://github.com/conventional-changelog/commitlint" target="_blank">commitlint</a>。\n\n***\n\n> 参考：\n>\n> - <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank">Conventional Commits</a>\n> - <a href="https://github.com/conventional-changelog/commitlint" target="_blank">commitlint</a>',
      date: 1643101532000,
      tags: ['Git'],
      title: 'Commit Message 相关规范整理',
      titleEng: 'commit-message',
      url: 'https://lzxjack.top/post?title=commit-message',
      _id: '5b049cc861efbe8608a5a4144623b1ca',
      _openid: 'dbee9976b3c14448a06f2006a4795cf2'
    },
    {
      classes: 'React 学习笔记',
      content:
        "## 1. 实现路由跳转\n\n实现了与`react-router-dom`的`5.x`版本相同的用法，包括`BrowserRouter`、`Link`、`Switch`、`Route`等组件，基本用法如下代码所示：\n\n```html\n<Router>\n    <div>\n        <Link to=\"/a\">组件A</Link>\n        <Link to=\"/b\">组件B</Link>\n        <Link to=\"/a/c\">组件C</Link>\n    </div>\n    <Switch>\n        <Route path=\"/a\" component={A} />\n        <Route path=\"/b\" component={B} />\n        <Route path=\"/a/c\" component={C} />\n    </Switch>\n</Router>\n```\n\n![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20220107194142.gif)\n\n## 2. BrowserRouter\n\n`BrowserRouter`组件需要将全部的组件包起来，利用`context`提供`history`对象和`location`对象。其中，`history`对象由`createBrowserHistory()`提供，`location`对象初始值是`window.location`。\n\n`history.listen()`用于监听`location`的变化，当其发生变化时，更新`state`中的`location`。\n\n```jsx\nimport { createContext, useState, useEffect } from 'react';\nimport { createBrowserHistory } from 'history';\n\nconst history = createBrowserHistory();\nexport const RouterContext = createContext();\n\nconst BrowserRouter = ({ children }) => {\n    const [location, setLocation] = useState(window.location);\n    useEffect(() => {\n        // 监听路由变化\n        const unlisten = history.listen(({ location: loc }) => {\n            setLocation(loc);\n        });\n        return () => {\n            unlisten && unlisten();\n        };\n    }, []);\n    return (\n        <RouterContext.Provider value={{ history, location }}>{children}</RouterContext.Provider>\n    );\n};\n\nexport default BrowserRouter;\n```\n\n## 3. Link\n\n`Link`组件里实际上是`a`链接。但点击路由时，实际上是不发生跳转的，所以在`onClick`事件里阻止了`a`链接跳转的默认行为。并且利用`history.push()`将当前的`location`推入`history`栈中，触发`BrowserRouter`中的监听器，更新`state`中的`location`。此时`window.location`也将更新，`url`会发生变化。\n\n```jsx\nimport { useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst style = {\n    border: '2px solid blue',\n    padding: '10px',\n    margin: '20px',\n    textDecoration: 'none',\n};\n\nconst Link = ({ to, children }) => {\n    const { history } = useContext(RouterContext);\n    return (\n        <a\n            href={to}\n            style={style}\n            onClick={e => {\n                e.preventDefault();\n                history.push(to);\n            }}\n        >\n            {children}\n        </a>\n    );\n};\n\nexport default Link;\n```\n\n## 4. Switch\n\n`Switch`组件将一系列`Route`组件包起来。若包含多个`Route`组件，则`children`是数组；若只有一个`Route`，`children`是单个元素，故进行判断，确保转化为数组。\n\n将`state`中`location.pathname`与包含的`Route`组件`path`进行对比，只渲染匹配上的`Route`。\n\n```jsx\nimport { useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst Switch = ({ children }) => {\n    const { location } = useContext(RouterContext);\n    const routes = Array.isArray(children) ? children : [children];\n    return (\n        <>\n            {routes.map(child => {\n                const {\n                    props: { path },\n                } = child;\n                if (location.pathname === path) return child;\n                return null;\n            })}\n        </>\n    );\n};\n\nexport default Switch;\n```\n\n## 5. Route\n\n将`state`中`location.pathname`与当前`Route`的`path`进行对比，若匹配上，则渲染传入的组件。\n\n```jsx\nimport { createElement, useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst Route = ({ path, component }) => {\n    const { location } = useContext(RouterContext);\n    return <>{location.pathname === path ? createElement(component) : null}</>;\n};\n\nexport default Route;\n```\n\n## 6. 源码\n\n<a href=\"https://github.com/lzxjack/mini-react-router\" target=\"_blank\">「GitHub」</a>\n\n\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      date: 1641559368000,
      tags: ['JavaScript', 'React'],
      title: 'mini-react-router 实现核心路由跳转功能',
      titleEng: 'mini-react-router',
      url: 'https://lzxjack.top/post?title=mini-react-router',
      _id: '5b049cc861d83561035ea0f11c262ec1',
      _openid: 'dbee9976b3c14448a06f2006a4795cf2'
    },
    {
      classes: 'CSS 常见问题',
      content:
        '最近把之前写的 <a href="https://github.com/lzxjack/react-todolist" target="_blank">TodoList</a> 小项目重构了一遍。比起之前的版本，重构后的项目改用 Hook，使用 Scss 作为 CSS 预处理器，`react-router-dom`升级到 V6 版本，同时使用了`rem`的移动端适配方案。本文就这次重构，总结这次的`rem`移动端适配实践。\n\n## 1. 几个概念\n\n### 1. 物理像素\n\n**物理像素**又叫**设备像素**，指的是屏幕上的显示单元，设备实际的像素点，由设备本身的屏幕决定。一个物理像素就是屏幕上一个最小的显示单元，每个显示单元都有自己的颜色和亮度。例如，某屏幕设备在宽度方向有 750 个像素点，高度方向有 1334 个像素点，就代表其真实的显示单元有 750 × 1334 个。\n\n### 2. 逻辑像素\n\n**逻辑像素**又叫**独立像素**，是由程序控制的虚拟像素，在 CSS 样式中，通常说的`px`就是逻辑像素。描述一张图片大小为`100px * 100px`，也是逻辑像素的表示。\n\n### 3. 设备像素比\n\n设备像素比（DPR）就是**物理像素**与**逻辑像素**的比值，即：\n\n```\nDPR = 物理像素 / 逻辑像素\n```\n\n在相同的**屏幕大小**下，显示**同等逻辑像素**的内容，设备像素比越大，则显示的效果越清晰。因为同样的**逻辑像素**，**设备像素比**较大的，会用更多的**物理像素**去显示。\n\n![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20220101171325.png)\n\n## 2. 移动端适配\n\n### 1. 方案\n\n在 <a href="https://github.com/lzxjack/react-todolist" target="_blank">TodoList</a> 小项目中，我采用的是移动端适配方案是`rem`适配。\n\n`rem`是值相对于根元素`<html>`字体大小的尺寸单位，如果`<HTML>`元素没有指定字体尺寸，那么以浏览器默认的字体尺寸为准。例如，`<HTML>`元素设置了字体尺寸为`24px`，那么`2rem`就代表`48px`。\n\n在`<HTML>`元素上设置特定的`font-size`值，通过**媒体查询**的方式，若当前设备宽度小于某个值时，采用`rem`单位的布局。\n\n但是不同用户的设备屏幕宽度不同，若每个用户对应的`<HTML>`元素`font-size`值相同的话，用户看到的显示效果也是不同的。\n\n可以用 JavaScript 来根据用户的屏幕宽度，动态更改`<HTML>`元素上的`font-size`值，从而使实际显示的内容比例始终保持不变，不同用户看到的效果也会保持一致。\n\n比如，设计稿的宽度为`400px`，里面显示了一个宽度为`40px`的盒子。某用户以`800px`宽度的设备来访问，看到的盒子宽度应该为`80`px。那么此时在`<HTML>`元素的`font-size`值设置为`2px`，然后盒子的宽度采用`rem`单位，设置为`40rem`，那么就能显示出`80px`的盒子了。保持用户看到的和设计稿中的效果比例一致。\n\n所以，`<HTML>`元素的`font-size`计算公式为：\n\n```\n( 用户设备宽度 / 设计稿标准宽度 ) * 100\n```\n\n这里乘以 100 只是一个系数，在写`rem`的时候，将标准设计稿中的宽度除以 100，就可以转化成了`rem`单位的宽度。\n\n例如，标准设计稿中某盒子宽度为`40px`，`40 / 100 = 0.4`，那么移动端适配时，改成`0.4rem`即可。\n\n### 2. 实践\n\n在页面下方加这样一段 JavaScript 代码，当 DOM 加载完成时，设置一次`<HTML>`元素的`font-size`值。同时监听设备宽度更改，设备宽度变化时，更新`<HTML>`元素的`font-size`值。\n\n```html\n<script type="text/javascript">\n    function inMobile() {\n        document.getElementsByTagName(\'html\')[0].style.fontSize =\n            (document.documentElement.clientWidth / 450) * 100 + \'px\';\n    }\n    document.addEventListener(\'DOMContentLoaded\', inMobile);\n    window.onresize = inMobile;\n</script>\n```\n\n样式中的代码，利用媒体查询，当设备宽度小于等于`900px`时，采用`rem`布局。否则，采用正常的 PC 端布局。\n\n```scss\n@media all and (max-width: 900px) {\n    .InputBox {\n        input {\n            width: 100%;\n            font-size: 0.24rem;\n        }\n    }\n}\n```\n\n\n\n***\n\n> 本文是自己学习之拙见，若有不妥，欢迎大佬指出交流~',
      date: 1641031119000,
      tags: ['CSS'],
      title: '一次移动端适配实践 —— rem布局',
      titleEng: 'mobile-rem',
      url: 'https://lzxjack.top/post?title=mobile-rem',
      _id: 'bf4a0bf261d026b90202b1c831d8b4c9',
      _openid: 'dbee9976b3c14448a06f2006a4795cf2'
    },
    {
      classes: '杂七杂八',
      content:
        '最近在实习，写了一个小需求。本地调试没问题后，提交代码，发现一直有两个错误：\n\n```powershell\nsubject may not be empty [subject-empty]\ntype may not be empty [type-empty]\n```\n\nMentor 指出，是我提交时的 Commit Message 不规范造成的。\n\n后来自己学习了一下 Commit Message 规范，记录成此笔记，若有不妥之处，欢迎批评指出～\n\n## 1. Commit Message 组成\n\n按照业界流行的 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank">Conventional Commits</a> 的相关规定，一个 Commit Message 的格式如下：\n\n```powershell\n<type>(<scope>): <subject>\n\n[optional body]\n\n[optional footer(s)]\n```\n\n整体的格式：\n\n- 包含三个部分：Header、Body、Footer\n- 其中，Header 是必需的，而 Body 和 Footer 可选\n- 每个部分之间有一个**空行**\n- 每行内容长度不能超过 100 个字符\n\n## 2. 每部分规范说明\n\n### 1. Header（必写）\n\n```powershell\n<type>(<scope>): <subject>\n```\n\n> 注意：冒号`:`和`<subject>`之间有一个**空格**。\n\n（1）type\n\n必填项，表示本次改动的提交类型，包括的类型有：\n\n- `build`：影响内部依赖和构建的修改，例如 glup，webpack，rollup 的配置等。\n- `chore`：其他不修改`src`或`test`文件的更改。\n- `ci`：更改`CI`的配置文件。\n- `docs`：文档更新。\n- `feat`：添加新功能。\n- `fix`：修复代码库的 Bug。\n- `perf`：提升性能的更改。\n- `refactor`：代码重构，没有设计修改 Bug 和新加功能。\n- `revert`：回滚到某个 commit 的提交。\n- `style`：格式修改，不涉及程序逻辑。\n- `test`：涉及测试用例的修改。\n\n（2）scope\n\n非必填，用于描述改动的影响范围，格式为`项目名/模块名`，标识此次提交主要涉及到代码中哪个模块。\n\n（3）subject\n\n必填项，此次提交的**描述内容**，语语句尽量简短。\n\n- 以动词原型开头，比如`change`，而不是`changes`\n- 第一个字母小写\n- 结尾不加句号`.`\n\n### 2. Body（可选）\n\nBody 部分是针对本次 commit 的**详细描述**，内容较长时，要进行合理的换行，要表达清楚变动的动机以及与之前行为的对比。好的提交信息要回答下面的内容：\n\n- 为什么要提交这次修改？\n- 怎么解决的问题？\n- 可能影响哪些内容？\n\n如果在 Body 上需要附上相关链接，则`ref: url`。\n\n### 3. Footer（可选）\n\nFooter 部分只用于两种情况：\n\n- BREAKING CHANGE（不兼容变动）\n- 关闭 Issue\n\n## 3. 一些 Commit 举例\n\n都省略了 Body 和 Footer。\n\n```powershell\nchore: run tests on travis ci\n```\n\n```powershell\nfix(server): send cors headers\n```\n\n```powershell\nfeat(blog): add comment section\n```\n\n## 4. 使用 commitlint 进行规范检查\n\ncommitlint 可以检查 Commit Message 是否符合 <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank">Conventional Commits</a> 的格式。\n\n详情配置见 <a href="https://github.com/conventional-changelog/commitlint" target="_blank">commitlint</a>。\n\n***\n\n> 参考：\n>\n> - <a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank">Conventional Commits</a>\n> - <a href="https://github.com/conventional-changelog/commitlint" target="_blank">commitlint</a>',
      date: 1643101532000,
      tags: ['Git'],
      title: 'Commit Message 相关规范整理',
      titleEng: 'commit-message',
      url: 'https://lzxjack.top/post?title=commit-message',
      _id: '5b049cc861efbe8608a5a4144623b1ca',
      _openid: 'dbee9976b3c14448a06f2006a4795cf2'
    },
    {
      classes: 'React 学习笔记',
      content:
        "## 1. 实现路由跳转\n\n实现了与`react-router-dom`的`5.x`版本相同的用法，包括`BrowserRouter`、`Link`、`Switch`、`Route`等组件，基本用法如下代码所示：\n\n```html\n<Router>\n    <div>\n        <Link to=\"/a\">组件A</Link>\n        <Link to=\"/b\">组件B</Link>\n        <Link to=\"/a/c\">组件C</Link>\n    </div>\n    <Switch>\n        <Route path=\"/a\" component={A} />\n        <Route path=\"/b\" component={B} />\n        <Route path=\"/a/c\" component={C} />\n    </Switch>\n</Router>\n```\n\n![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20220107194142.gif)\n\n## 2. BrowserRouter\n\n`BrowserRouter`组件需要将全部的组件包起来，利用`context`提供`history`对象和`location`对象。其中，`history`对象由`createBrowserHistory()`提供，`location`对象初始值是`window.location`。\n\n`history.listen()`用于监听`location`的变化，当其发生变化时，更新`state`中的`location`。\n\n```jsx\nimport { createContext, useState, useEffect } from 'react';\nimport { createBrowserHistory } from 'history';\n\nconst history = createBrowserHistory();\nexport const RouterContext = createContext();\n\nconst BrowserRouter = ({ children }) => {\n    const [location, setLocation] = useState(window.location);\n    useEffect(() => {\n        // 监听路由变化\n        const unlisten = history.listen(({ location: loc }) => {\n            setLocation(loc);\n        });\n        return () => {\n            unlisten && unlisten();\n        };\n    }, []);\n    return (\n        <RouterContext.Provider value={{ history, location }}>{children}</RouterContext.Provider>\n    );\n};\n\nexport default BrowserRouter;\n```\n\n## 3. Link\n\n`Link`组件里实际上是`a`链接。但点击路由时，实际上是不发生跳转的，所以在`onClick`事件里阻止了`a`链接跳转的默认行为。并且利用`history.push()`将当前的`location`推入`history`栈中，触发`BrowserRouter`中的监听器，更新`state`中的`location`。此时`window.location`也将更新，`url`会发生变化。\n\n```jsx\nimport { useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst style = {\n    border: '2px solid blue',\n    padding: '10px',\n    margin: '20px',\n    textDecoration: 'none',\n};\n\nconst Link = ({ to, children }) => {\n    const { history } = useContext(RouterContext);\n    return (\n        <a\n            href={to}\n            style={style}\n            onClick={e => {\n                e.preventDefault();\n                history.push(to);\n            }}\n        >\n            {children}\n        </a>\n    );\n};\n\nexport default Link;\n```\n\n## 4. Switch\n\n`Switch`组件将一系列`Route`组件包起来。若包含多个`Route`组件，则`children`是数组；若只有一个`Route`，`children`是单个元素，故进行判断，确保转化为数组。\n\n将`state`中`location.pathname`与包含的`Route`组件`path`进行对比，只渲染匹配上的`Route`。\n\n```jsx\nimport { useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst Switch = ({ children }) => {\n    const { location } = useContext(RouterContext);\n    const routes = Array.isArray(children) ? children : [children];\n    return (\n        <>\n            {routes.map(child => {\n                const {\n                    props: { path },\n                } = child;\n                if (location.pathname === path) return child;\n                return null;\n            })}\n        </>\n    );\n};\n\nexport default Switch;\n```\n\n## 5. Route\n\n将`state`中`location.pathname`与当前`Route`的`path`进行对比，若匹配上，则渲染传入的组件。\n\n```jsx\nimport { createElement, useContext } from 'react';\nimport { RouterContext } from './BrowserRouter';\n\nconst Route = ({ path, component }) => {\n    const { location } = useContext(RouterContext);\n    return <>{location.pathname === path ? createElement(component) : null}</>;\n};\n\nexport default Route;\n```\n\n## 6. 源码\n\n<a href=\"https://github.com/lzxjack/mini-react-router\" target=\"_blank\">「GitHub」</a>\n\n\n\n***\n\n> 以上是本人学习所得之拙见，若有不妥，欢迎指出交流！",
      date: 1641559368000,
      tags: ['JavaScript', 'React'],
      title: 'mini-react-router 实现核心路由跳转功能',
      titleEng: 'mini-react-router',
      url: 'https://lzxjack.top/post?title=mini-react-router',
      _id: '5b049cc861d83561035ea0f11c262ec1',
      _openid: 'dbee9976b3c14448a06f2006a4795cf2'
    },
    {
      classes: 'CSS 常见问题',
      content:
        '最近把之前写的 <a href="https://github.com/lzxjack/react-todolist" target="_blank">TodoList</a> 小项目重构了一遍。比起之前的版本，重构后的项目改用 Hook，使用 Scss 作为 CSS 预处理器，`react-router-dom`升级到 V6 版本，同时使用了`rem`的移动端适配方案。本文就这次重构，总结这次的`rem`移动端适配实践。\n\n## 1. 几个概念\n\n### 1. 物理像素\n\n**物理像素**又叫**设备像素**，指的是屏幕上的显示单元，设备实际的像素点，由设备本身的屏幕决定。一个物理像素就是屏幕上一个最小的显示单元，每个显示单元都有自己的颜色和亮度。例如，某屏幕设备在宽度方向有 750 个像素点，高度方向有 1334 个像素点，就代表其真实的显示单元有 750 × 1334 个。\n\n### 2. 逻辑像素\n\n**逻辑像素**又叫**独立像素**，是由程序控制的虚拟像素，在 CSS 样式中，通常说的`px`就是逻辑像素。描述一张图片大小为`100px * 100px`，也是逻辑像素的表示。\n\n### 3. 设备像素比\n\n设备像素比（DPR）就是**物理像素**与**逻辑像素**的比值，即：\n\n```\nDPR = 物理像素 / 逻辑像素\n```\n\n在相同的**屏幕大小**下，显示**同等逻辑像素**的内容，设备像素比越大，则显示的效果越清晰。因为同样的**逻辑像素**，**设备像素比**较大的，会用更多的**物理像素**去显示。\n\n![](https://jack-img.oss-cn-hangzhou.aliyuncs.com/img/20220101171325.png)\n\n## 2. 移动端适配\n\n### 1. 方案\n\n在 <a href="https://github.com/lzxjack/react-todolist" target="_blank">TodoList</a> 小项目中，我采用的是移动端适配方案是`rem`适配。\n\n`rem`是值相对于根元素`<html>`字体大小的尺寸单位，如果`<HTML>`元素没有指定字体尺寸，那么以浏览器默认的字体尺寸为准。例如，`<HTML>`元素设置了字体尺寸为`24px`，那么`2rem`就代表`48px`。\n\n在`<HTML>`元素上设置特定的`font-size`值，通过**媒体查询**的方式，若当前设备宽度小于某个值时，采用`rem`单位的布局。\n\n但是不同用户的设备屏幕宽度不同，若每个用户对应的`<HTML>`元素`font-size`值相同的话，用户看到的显示效果也是不同的。\n\n可以用 JavaScript 来根据用户的屏幕宽度，动态更改`<HTML>`元素上的`font-size`值，从而使实际显示的内容比例始终保持不变，不同用户看到的效果也会保持一致。\n\n比如，设计稿的宽度为`400px`，里面显示了一个宽度为`40px`的盒子。某用户以`800px`宽度的设备来访问，看到的盒子宽度应该为`80`px。那么此时在`<HTML>`元素的`font-size`值设置为`2px`，然后盒子的宽度采用`rem`单位，设置为`40rem`，那么就能显示出`80px`的盒子了。保持用户看到的和设计稿中的效果比例一致。\n\n所以，`<HTML>`元素的`font-size`计算公式为：\n\n```\n( 用户设备宽度 / 设计稿标准宽度 ) * 100\n```\n\n这里乘以 100 只是一个系数，在写`rem`的时候，将标准设计稿中的宽度除以 100，就可以转化成了`rem`单位的宽度。\n\n例如，标准设计稿中某盒子宽度为`40px`，`40 / 100 = 0.4`，那么移动端适配时，改成`0.4rem`即可。\n\n### 2. 实践\n\n在页面下方加这样一段 JavaScript 代码，当 DOM 加载完成时，设置一次`<HTML>`元素的`font-size`值。同时监听设备宽度更改，设备宽度变化时，更新`<HTML>`元素的`font-size`值。\n\n```html\n<script type="text/javascript">\n    function inMobile() {\n        document.getElementsByTagName(\'html\')[0].style.fontSize =\n            (document.documentElement.clientWidth / 450) * 100 + \'px\';\n    }\n    document.addEventListener(\'DOMContentLoaded\', inMobile);\n    window.onresize = inMobile;\n</script>\n```\n\n样式中的代码，利用媒体查询，当设备宽度小于等于`900px`时，采用`rem`布局。否则，采用正常的 PC 端布局。\n\n```scss\n@media all and (max-width: 900px) {\n    .InputBox {\n        input {\n            width: 100%;\n            font-size: 0.24rem;\n        }\n    }\n}\n```\n\n\n\n***\n\n> 本文是自己学习之拙见，若有不妥，欢迎大佬指出交流~',
      date: 1641031119000,
      tags: ['CSS'],
      title: '一次移动端适配实践 —— rem布局',
      titleEng: 'mobile-rem',
      url: 'https://lzxjack.top/post?title=mobile-rem',
      _id: 'bf4a0bf261d026b90202b1c831d8b4c9',
      _openid: 'dbee9976b3c14448a06f2006a4795cf2'
    }
  ],
  total: 100,
  pageSize: 10,
  pageNum: 1
}
export const jirishiju = 'aaaaa'
export default {}
